using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace ECMASCript.MSBuild;

public class GenerateWhiteListTask : Task
{
	[Required]
	public ITaskItem[] SourceFiles { get; set; } = [];

	[Required]
	public string? OutputFile { get; set; }

	private static bool IsWhiteListAttribute(AttributeSyntax attr)
	{
		var name = attr.Name.ToString();
		return name == "WhiteListAttribute" || name == "WhiteList";
	}	

	public override bool Execute()
	{
		if (OutputFile is null)
		{
			Log.LogError("OutputFile is required.");
			return false;
		}

		try
		{
			// 解析所有源文件
			var syntaxTrees = SourceFiles
				.Select(f => CSharpSyntaxTree.ParseText(File.ReadAllText(f.ItemSpec)))
				.ToList();

			// 提取类名和方法名
			var classNames = new List<string>();
			var methodNames = new List<string>();

			foreach (var tree in syntaxTrees)
			{
				var root = tree.GetRoot();

				// 查找所有类声明
				var classDeclarations = root.DescendantNodes()
					.OfType<ClassDeclarationSyntax>();

				foreach (var classDecl in classDeclarations)
				{
					var classAttrs = classDecl.AttributeLists
						.SelectMany(a => a.Attributes)
						.Where(IsWhiteListAttribute)
						.ToList();

					if (classAttrs.Count == 0)
						continue;

					foreach (var attr in classAttrs)
					{
						var expression = attr.ArgumentList!.Arguments[0].Expression;
						if (expression is LiteralExpressionSyntax literal)
							classNames.Add(literal.Token.ValueText);
					}

					foreach (var methodDecl in classDecl.DescendantNodes().OfType<MethodDeclarationSyntax>())
					{
						foreach (var list in methodDecl.AttributeLists)
						{
							foreach (var attr in list.Attributes)
							{
								if (IsWhiteListAttribute(attr) &&
									attr.ArgumentList!.Arguments[0].Expression is LiteralExpressionSyntax literal &&
									!string.IsNullOrWhiteSpace(literal.Token.ValueText))
									methodNames.Add(literal.Token.ValueText);
							}
						}
					}
				}
			}

			// 生成源代码
			var source = $@"// <auto-generated/>
using System.Collections.Generic;

namespace ECMAScript.Analyzer;

public static class WhiteList
{{
    public static readonly HashSet<string> Types = new HashSet<string>
    {{
        {string.Join(",\n        ", classNames.Select(n => $"\"{n}\""))}
    }};

    public static readonly HashSet<string> Members = new HashSet<string>
    {{
        {string.Join(",\n        ", methodNames.Select(n => $"\"{n}\""))}
    }};
}}";

			// 确保输出目录存在
			var outputDir = Path.GetDirectoryName(OutputFile);
			if (!Directory.Exists(outputDir))
			{
				Directory.CreateDirectory(outputDir);
			}

			// 写入文件
			File.WriteAllText(OutputFile, source);
			return true;
		}
		catch (Exception ex)
		{
			Log.LogErrorFromException(ex);
			return false;
		}
	}
}

