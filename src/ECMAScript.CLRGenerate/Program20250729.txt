// See https://aka.ms/new-console-template for more information
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.ObjectModel;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml.Linq;

static string? GetComment(ISymbol? symbol)
{
	var xml = symbol?.GetDocumentationCommentXml();
	if (string.IsNullOrEmpty(xml))
		return null;

	var member = XElement.Parse(xml);
	var builder = new StringBuilder();
	foreach (var node in member.Nodes())
	{
		builder.Append($"    ///{node.ToString().Replace(Environment.NewLine,"")}{Environment.NewLine}");
	}
	return builder.ToString().TrimEnd('\n');
}

var format = new SymbolDisplayFormat(
	globalNamespaceStyle:
		// 不包含 
		SymbolDisplayGlobalNamespaceStyle.Omitted,
	typeQualificationStyle:
		//保留完整的命名空间路径
		SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
	genericsOptions:
		// 不显示泛型参数
		SymbolDisplayGenericsOptions.IncludeTypeParameters,
	memberOptions:
		//SymbolDisplayMemberOptions.IncludeType |
		SymbolDisplayMemberOptions.IncludeModifiers |
		//SymbolDisplayMemberOptions.IncludeAccessibility |
		SymbolDisplayMemberOptions.IncludeExplicitInterface |
		SymbolDisplayMemberOptions.IncludeParameters |
		SymbolDisplayMemberOptions.IncludeContainingType |
		SymbolDisplayMemberOptions.IncludeConstantValue |
		SymbolDisplayMemberOptions.IncludeRef,
	delegateStyle:
		SymbolDisplayDelegateStyle.NameAndParameters,
	extensionMethodStyle:
		 SymbolDisplayExtensionMethodStyle.InstanceMethod,
	parameterOptions:
		SymbolDisplayParameterOptions.IncludeType |
		SymbolDisplayParameterOptions.IncludeModifiers |
		SymbolDisplayParameterOptions.IncludeParamsRefOut,
	propertyStyle:
		SymbolDisplayPropertyStyle.ShowReadWriteDescriptor,
	localOptions:
		SymbolDisplayLocalOptions.IncludeType|
		SymbolDisplayLocalOptions.IncludeModifiers |
		SymbolDisplayLocalOptions.IncludeConstantValue,
	kindOptions: 
		SymbolDisplayKindOptions.None,
	miscellaneousOptions:
		SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |
		SymbolDisplayMiscellaneousOptions.UseSpecialTypes
);

//var xmlDir = @"C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\10.0.0-preview.5.25277.114\ref\net10.0";
var coreLibXml = XmlDocumentationProvider.CreateFromFile(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "System.Private.CoreLib.xml"));
var numericsXml = XmlDocumentationProvider.CreateFromFile(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "System.Runtime.Numerics.xml"));
var compilation = CSharpCompilation.Create("Jazor", references: [
	MetadataReference.CreateFromFile(typeof(object).Assembly.Location, documentation:coreLibXml),
	MetadataReference.CreateFromFile(typeof(BigInteger).Assembly.Location,documentation:numericsXml),
]);


var types = new Type[]{
	// 基本类型
	//typeof(void),
	typeof(Object),
	typeof(Boolean),
	typeof(Char),
	typeof(SByte),
	typeof(Byte),
	typeof(Int16),
	typeof(UInt16),
	typeof(Int32),
	typeof(UInt32),
	typeof(Int64),
	typeof(UInt64),
	typeof(Single),
	typeof(Double),
	typeof(Decimal),
	typeof(DateTime),
	typeof(DateOnly),
	typeof(TimeOnly),
	typeof(DateTimeOffset),
	typeof(TimeSpan),
	typeof(String),
	typeof(BigInteger),
	typeof(Exception),
	typeof(StringBuilder),
	typeof(Nullable),
	typeof(ValueTuple),
	typeof(WeakReference),
	typeof(List<>),
	typeof(Dictionary<,>),
	typeof(HashSet<>),
	typeof(ReadOnlyCollection),
	typeof(ReadOnlyDictionary<,>),
	typeof(ReadOnlySet<>),
	typeof(ConditionalWeakTable<,>),
};
var ECMAMaps = new Dictionary<Type, string>()
{
	//{typeof(void),"void"},
	{typeof(Object),"Object"},
	{typeof(Boolean),"Boolean"},
	{typeof(Char),"String"},
	{typeof(SByte),"String"},
	{typeof(Byte),"Number"},
	{typeof(Int16),"Number"},
	{typeof(UInt16),"Number"},
	{typeof(Int32),"Number"},
	{typeof(UInt32),"Number"},
	{typeof(Int64),"Number"},
	{typeof(UInt64),"Number"},
	{typeof(Single),"Number"},
	{typeof(Double),"Number"},
	{typeof(Decimal),"Number"},
	{typeof(DateTime),"Date"},
	{typeof(DateOnly),"Date"},
	{typeof(TimeOnly),"Date"},
	{typeof(DateTimeOffset),"Date"},
	{typeof(TimeSpan),"Number"},
	{typeof(String),"String"},
	{typeof(BigInteger),"BigInt"},
	{typeof(Exception),"Error"},
	//{typeof(StringBuilder),""},
	//{typeof(Nullable),"null"},
	//{typeof(ValueTuple),""},
	{typeof(WeakReference),"WeakRef"},
	//{typeof(Action),""},
	//{typeof(Func<>),""},
	{typeof(List<>),"Array<T>"},
	{typeof(Dictionary<,>),"Map<TKey,TValue>"},
	{typeof(HashSet<>),"Set<T>"},
	{typeof(ReadOnlyCollection),"Array<T>"},
	{typeof(ReadOnlyDictionary<,>),"Map<TKey,TValue>"},
	{typeof(ReadOnlySet<>),"Set<T>"},
	{typeof(ConditionalWeakTable<,>),"WeakSet<T>"},
};

//var directory = Path.Combine(Directory.GetParent(AppDomain.CurrentDomain.BaseDirectory)!.Parent!.Parent!.Parent!.FullName, "generate");
var directory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "generate");

if (!Directory.Exists(directory))
	Directory.CreateDirectory(directory);

foreach (var type in types)
{
	var builder = new StringBuilder();
	var symbol = compilation.GetTypeByMetadataName(type.FullName!)!;
	var typeName = type.Name.Split('`')[0];
	var fullName = symbol.ToDisplayString(format);
	var generics = symbol.TypeArguments.Length > 0
		? $"<{string.Join(", ", symbol.TypeArguments.Select(x => x.Name))}>"
		: "";

	if (!ECMAMaps.TryGetValue(type, out var mapName))
		mapName = fullName;
	
	builder.Append($@"using System.Collections;

namespace ECMAScript;

[ECMAScriptModule]
[WhiteList(""{fullName}"")]
public static class {typeName}Module{generics}
{{");

	var keys = new List<string>();
	var methods = new List<string>(); 
	foreach (var member in symbol.GetMembers())
	{
		if (member.DeclaredAccessibility.HasFlag(Accessibility.Public))
		{
			var key = member.ToDisplayString(format);
			var comment = GetComment(member);

			if (member is IFieldSymbol field)
			{
				if (field.IsConst)
				{
					builder.AppendLine($@"{Environment.NewLine}	//{field.ToDisplayString()} = {field.ConstantValue};");
				}
				else
				{
					var para = field.IsStatic ? string.Empty : $"{mapName} instance";
					builder.Append($@"
{comment}    [WhiteList(""{key}"")]
	public extern static {mapName} {typeName}{field.Name}({para});
");

					keys.Add(key);
				}
			}
			else if (member is IMethodSymbol method)
			{
				if (method.MethodKind == MethodKind.PropertyGet || method.MethodKind == MethodKind.PropertySet)
				{
					var prop = (IPropertySymbol)method.AssociatedSymbol!;
					var para = method.Parameters.Length > 0
						? $"{mapName} instance, {string.Join(", ", method.Parameters.Select(p => p.ToDisplayString()))}"
						: $"{mapName} instance";
					var op = prop.IsStatic
						? $"PropertyReference2Literal, \"{prop.Name}\""
						: "PropertyReference2CallExpression";
					var methodName = method.MethodKind == MethodKind.PropertyGet
						? "Get"
						: "Set";

					if (prop.IsIndexer)
						methodName = "This";
					else
						methodName += prop.Name;

					builder.Append($@"
{comment}    [WhiteList(""{key}"")]
	public extern static {prop.Type.ToDisplayString()} {typeName}{methodName}({para});
");

					keys.Add(key);
				}
				else if(method.MethodKind != MethodKind.Destructor && method.MethodKind != MethodKind.Conversion)
				{
					var op = "Invocation2CallExpression";
					var methodName = string.Empty;
					var returnType = method.ReturnType.ToDisplayString();

					if (method.MethodKind == MethodKind.Constructor)
					{
						if (mapName == "BigInt" && method.Parameters.Length ==1)
							op = "ObjectCreation2CallExpression, \"BigInt\"";
						methodName = $"New{typeName}";
						returnType = mapName;
					}

					//else if (method.MethodKind == MethodKind.Destructor)
					//	methodName = $"Des{typeName}";

					else if (method.Name.StartsWith("op_", StringComparison.InvariantCulture))
						methodName += method.Name.Replace("op_", "Op", StringComparison.InvariantCulture);

					else
						methodName = method.Name;

					//if (methodName == "NewBigInteger")
					//{
					//	var a = 3;
					//}

					methods.Add(method.Name);
					var count = methods.Count(x => x == method.Name);

					var para = string.Join(", ", method.Parameters.Select(p => p.ToDisplayString()));
					var suffix = count == 1 ? string.Empty : count.ToString();
					builder.Append($@"
{comment}    [WhiteList(""{key}"")]
	public extern static {returnType} {typeName}{methodName}{suffix}{generics}({para});
");

					keys.Add(key);
				}
			}
		}
	}

	builder.AppendLine($@"
	/// <summary>
	/// {keys.Count} WhiteList Member
	/// </summary>
    public static readonly string[] MemberWhiteList = [
		{string.Join(",\n\t\t", keys.Select(x => $"\"{x}\""))}
	];");

	builder.AppendLine("}");

	File.WriteAllText(Path.Combine(directory, $"{typeName}Module.cs"), builder.ToString());
	Console.WriteLine(typeName);
}

Type[] whiteListTypes = [
		// 基本类型
		typeof(void),
		typeof(Object),
		typeof(Boolean),
		typeof(Char),
		typeof(IntPtr),
		typeof(UIntPtr),
		typeof(SByte),
		typeof(Byte),
		typeof(Int16),
		typeof(UInt16),
		typeof(Int32),
		typeof(UInt32),
		typeof(Int64),
		typeof(UInt64),
		typeof(Single),
		typeof(Double),
		typeof(Decimal),
		typeof(DateTime),
		typeof(DateOnly),
		typeof(TimeOnly),
		typeof(DateTimeOffset),
		typeof(TimeSpan),
		typeof(String),
		typeof(BigInteger),
		typeof(Exception),
		typeof(StringBuilder),
		// 泛型或其他类型
		typeof(Nullable),
		typeof(ValueTuple),
		typeof(WeakReference),
		typeof(Action),
		typeof(Func<>),
		typeof(List<>),
		typeof(Dictionary<,>),
		typeof(HashSet<>),
		typeof(ReadOnlyCollection),
		typeof(ReadOnlyDictionary<,>),
		typeof(ReadOnlySet<>),
		typeof(ConditionalWeakTable<,>)
	];
var whiteListTypeNames = whiteListTypes
	.Select(type => compilation.GetTypeByMetadataName(type.FullName!).ToDisplayString(format))
	.Select(type => $"\"{type}\"");

var whiteListTypeName = string.Join($", \n", whiteListTypeNames);

var name = compilation.GetTypeByMetadataName(typeof(List<>).FullName)
	.Construct(compilation.GetSpecialType(SpecialType.System_Int32))
	.ToDisplayString(format);

Console.WriteLine(whiteListTypeName);
Console.ReadLine();