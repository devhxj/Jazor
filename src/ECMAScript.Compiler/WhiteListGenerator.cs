using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;

namespace ECMAScript.Compiler;

[Generator]
public class WhiteListGenerator : IIncrementalGenerator
{
	private class WhlteListItem(TextSpan source, SyntaxKind kind)
	{
		public TextSpan Source { get; } = source;

		public SyntaxKind Kind { get; } = kind;

		public List<string> Keys { get; } = [];

		public bool Obsolete { get; set; }

		public string? Code { get; set; }

		public bool Inject { get; set; }

		public string[]? Imports { get; set; }
	}

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var declarations = context.SyntaxProvider.ForAttributeWithMetadataName(
			"ECMAScript.WhiteListAttribute",
			predicate: (node, _) => node is ClassDeclarationSyntax or MethodDeclarationSyntax,
			transform: (context, _) => context.TargetNode
		);

		var whlteListItems = declarations
			.Select((x, _) =>
			{
				var member = (MemberDeclarationSyntax)x;
				var data = new WhlteListItem(member.GetLocation().SourceSpan, member.Kind());
				foreach (var list in member.AttributeLists)
				{
					foreach (var attr in list.Attributes)
					{
						var name = attr.Name.ToString();
						if (name == "WhiteListAttribute" || name == "WhiteList")
						{
							var key = attr.ArgumentList!.Arguments[0].Expression;
							var value = key switch
							{
								LiteralExpressionSyntax literal => literal.Token.ValueText,
								_ => null,
							};

							if (value is not null)
								data.Keys.Add(value);
						}
						else if (name == "ECMAScriptLiteralAttribute" || name == "ECMAScriptLiteral")
						{
							var code = attr.ArgumentList!.Arguments[0].Expression;
							data.Code = code switch
							{
								LiteralExpressionSyntax literal => literal.Token.ValueText,
								_ => null,
							};

							if (attr.ArgumentList!.Arguments.Count > 1)
							{
								var inject = attr.ArgumentList!.Arguments[1].Expression;
								data.Inject = inject switch
								{
									LiteralExpressionSyntax literal => literal.IsKind(SyntaxKind.TrueLiteralExpression),
									_ => false
								};
							}

							if (attr.ArgumentList!.Arguments.Count > 2)
							{
								var imports = attr.ArgumentList!.Arguments[2].Expression;
								data.Imports = imports switch
								{
									ArrayCreationExpressionSyntax arrayCreation => [
										.. arrayCreation.Initializer!.Expressions
									.OfType<LiteralExpressionSyntax>()
									.Select(lit => lit.Token.ValueText)
									],
									ImplicitArrayCreationExpressionSyntax implicitArray => [
										.. implicitArray.Initializer!.Expressions
									.OfType<LiteralExpressionSyntax>()
									.Select(lit => lit.Token.ValueText)
									],
									_ => null
								};
							}
						}
						else if (name == "ObsoleteAttribute" || name == "Obsolete")
							data.Obsolete = true;
					}
				}

				//Debugger.Launch();
				return data;
			})
			.Where(x => !x.Obsolete)
			.Collect();

		context.RegisterSourceOutput(whlteListItems, (spc, datas) =>
		{
			var classNames = new List<string>();
			var methodNames = new List<string>();

			foreach (var data in datas)
			{
				if (data.Kind == SyntaxKind.MethodDeclaration)
					methodNames.AddRange(data.Keys);
				else
					classNames.AddRange(data.Keys);
			}
			// 生成源代码
			var source = $@"// <auto-generated/>
namespace ECMAScript.CLR;

public static class WhiteList
{{
    public static readonly HashSet<string> Types = [
		{string.Join(",\n        ", classNames.Select(n => $"\"{n}\""))}
    ];

	public static readonly HashSet<string> Members = [
        {string.Join(",\n        ", methodNames.Select(n => $"\"{n}\""))}
    ];
}}";
			spc.AddSource("WhiteList.g.cs", source);
		});
	}
}
